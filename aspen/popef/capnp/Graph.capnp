@0xc4c8a9f3abb016e7; # unique file ID, generated by `capnp id`

using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("poplar::cap");

using Common = import "Common.capnp";
using CoreCom = import "CoreCommon.capnp";
using Common.SimpleType;
using CoreCom.VarRegion;
using CoreCom.Region;

using Target = import "TargetInfo.capnp";
using Target.TargetInfo;

struct Edge {
  # The index into VertexType::fields, i.e. the first field in the vertex is 0,
  # the second is 1, etc.
  ordinal @0 :UInt16;
  # The index into the field, e.g. if it is a VectorList, the index in that.
  # Set to zero if there is no index, e.g. Input<float>.
  index @1 :UInt32;
  # Regions it is connected to.
  regions @2 :List(VarRegion);
}

struct InitValue {
  # The index into VertexType::fields, i.e. the first field in the vertex is 0,
  # the second is 1, etc.
  ordinal @0 :UInt16;
  # The initialisation value
  value @1 :Data;
}

struct Vertex {
  # The type of vertex, this is an index into Graph::vertexTypes.
  vertexType @0 :UInt32;
  # A list of connections from variables to the vertex's fields.
  edges @1 :List(Edge);
  # The tile the vertex is mapped to. Unmapped vertices are set to 2^32-1.
  tile @2 :UInt32;
  # A list initialisation values for non-edge vertex fields
  initValues @3 :List(InitValue);
}

struct ComputeSet {
  # Name of the compute set.
  name @0 :Text;
  # The list of vertices in the compute set. For each vertex its
  vertices @1 :List(Vertex);
}

struct RegionTileMapping {
  tile @0 :UInt32;
  region @1 :Region;
}

struct Var {
  name @0 :Text;
  numElements @1 :UInt32;
  isConstant @2 :Bool;
  alignment @3 :UInt8;
  type @4 :SimpleType;
  tileMapping @5 :List(RegionTileMapping);
}

struct VertexField {
  name @0 :Text;
  type @1 :Text;
}

enum VertexKind {
  worker @0;
  supervisor @1;
  externalExchange @2;
  multiWorker @3;
}

# A vertex type that is used in the graph.
struct VertexType {
  name @0 :Text;
  kind @1 :VertexKind;
  size @2 :UInt32;
  align @3 :UInt32;

  fields @4 :List(VertexField);
}

# A list of var regions to copy from and to. The total length must be the same.
struct Copy {
  src @0 :List(VarRegion);
  dst @1 :List(VarRegion);
}

# A serialised graph. Note that this is the serialisation of an *unlowered*
# graph, i.e. before compilation. This means that, for example:
#
# * All the `var_id`s are of unlowered variables so they won't match the
#   `var_id`s in VariableAllocator.capnp
# * Compute sets added during compilation (e.g. for on-tile copies) will
#   not be present.
#
struct Graph {
  # List of variables indexed by [tile][var_id].
  vars @0 :List(List(Var));

  # List of vertex types that are used in the graph, indexed by vertex_tag
  vertexTypes @1 :List(VertexType);

  # The compute sets, including the vertices within them, and the connections
  # for those vertices.
  computeSets @2 :List(ComputeSet);

  # Basic information about the target this graph was constructed for, since
  # it affects the graph construction (e.g. tile mapping depends on the
  # number of tiles).
  targetInfo @3 :TargetInfo;

  # These are the source and target `VarRegion`s of each `Copy`
  # which covers every type of copy except host copies.
  copies @4 :List(Copy);
}
