@0xc37c011da25f1716; # Unique ID; Generated by `capnp id`
using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("poplar::cap");

using Common = import "Common.capnp";
using CoreCom = import "CoreCommon.capnp";
using MutableGraph = import "MutableGraph.capnp";

using Common.SimpleType;
using CoreCom.VarRegion;
using Common.Region;
using CoreCom.OptRegion;
using CoreCom.RegionList;
using Common.GenListUInt32;

using CoreCom.CoreFieldNameTag;
using CoreCom.StreamAndIndex;
using CoreCom.CoreVarId;
using CoreCom.VarIdList;
using CoreCom.VarOffset;
using CoreCom.OptVarId;
using CoreCom.OptVarIdList;
using CoreCom.GenListBool;
using CoreCom.OptUInt32;
using CoreCom.CoreSizeT;
using CoreCom.VSizeT;
using CoreCom.OptVSizeT;
using CoreCom.GenListVSizeT;
using CoreCom.DataStreamId;
using CoreCom.OptDataStreamId;
using CoreCom.OptDataStreamIdList;
using CoreCom.TextToBoolMap;
using CoreCom.TextToUInt32Map;
using CoreCom.UnorderedBitset;
using CoreCom.CoreTypeTag;
using CoreCom.CoreVertexId;
using CoreCom.CoreVertexTypeTag;
using CoreCom.SmallListChar;
using CoreCom.GraphRelocationList;
using MutableGraph.MGraph;

# FieldTagOrVertex
struct CoreFieldTagOrVertex {
  hasTag @0: Bool;
  tag    @1:  CoreFieldNameTag;
}

# OptStreamAndIndex
# TBD : Use StreamAndIndex. Move both to Common
struct OptStreamAndIndex {
  hasValue @0: Bool;
  id       @1: UInt32;
  index    @2: UInt32;
}

# VertexIdAndFieldNameTag
struct CoreVIdAndFieldNameTag {
  vertexId @0: CoreVertexId;
  fieldNameTag @1: CoreFieldNameTag;
}

# VertexFieldInfo
struct CoreVertexFieldInfo {
  typeTag @0: CoreTypeTag;
  offset @1: UInt32;
}

# VertexFieldOrdinal
struct CoreVertexFieldOrdinal {
  dim0 @0: UInt32;
  dim1 @1: UInt32;
  ordinal @2: List(OrdinalList);
  struct OrdinalList {
    size @0: UInt32;
    list @1: List(UInt32);
  }
}

# NameTagVertexFieldPair
struct CoreNameTagVertexFieldPair {
  nameTag @0: CoreFieldNameTag;
  fieldInfo @1: CoreVertexFieldInfo;
}

struct CoreVec2DTagFieldInfo {
  size @0: UInt32;
  list @1: List(NameTagVertexFieldList);

  struct NameTagVertexFieldList {
    size @0: UInt32;
    list @1: List(CoreNameTagVertexFieldPair);
  }
}
struct CoreVertexInfo {
  name       @0: Text;
  size       @1: UInt32;
  align      @2: UInt32;
  kind       @3:  Kind;
  immutable  @4: Bool;
  sourceType @5: SourceType;
  needsAlignWorkers @6: Bool;
  mayDirectlyAccessExternalVariables @7: Bool;

  enum Kind {
    worker @0;
    supervisor @1;
    externalexchange @2;
    multiworker @3;
  }
  enum SourceType {
      asm @0;
      cpp @1;
  }
}
struct CoreVertexInfoList {
  size @0: UInt32;
  list @1: List(CoreVertexInfo);
}

struct CoreLayout {
  enum Vector {
    notAVector    @0;
    span          @1;
    shortSpan     @2;
    onePtr        @3;
    scaledPtr32   @4;
    scaledPtr64   @5;
    scaledPtr128  @6;
  }
  enum VectorList {
    notAVector     @0;
    onePtr         @1;
    scaledPtr32    @2;
    scaledPtr64    @3;
    scaledPtr128   @4;
    deltaN         @5;
    deltaNElements @6;
  }
  data @0: UInt32;
}

struct CoreFieldTypeInfoList {
  size @0: UInt32;
  list @1: List(CoreFieldTypeInfo);
}

struct CoreFieldTypeInfo {
  kind               @0: Kind;
  elementTypeTag     @1: CoreTypeTag;
  simpleType         @2: SimpleType;
  vectorMinAlignment @3: UInt64;
  interleaved        @4: Bool;
  vectorLayout       @5: CoreLayout.Vector;
  vectorListLayout   @6: CoreLayout.VectorList;

  enum Kind {
    simple @0;
    input @1;
    vector @2;
    vectorList @3;
    output @4;
    inout @5;
  }
}
struct CoreFieldTagNames {
  size @0: UInt32;
  list @1: List(Text);
}

# VertexMemConstraintInfo
struct CoreMemConstraintInfo {
  vertexTypeTag @0: CoreVertexTypeTag;
  constraintKind @1: ConstraintKind;
  constraintToStack @2: Bool;
  leftFieldNameTag @3: CoreFieldTagOrVertex;
  leftIndirectionLevel @4: UInt32;
  rightFieldNameTag @5: CoreFieldTagOrVertex;
  rightIndirectionLevel @6: UInt32;

  enum ConstraintKind {
    element @0;
    region @1;
  }
}
struct CoreMemConstraintList {
  size @0: UInt32;
  list @1: List(CoreMemConstraintInfo);
}

struct CoreGraphTypeInfo {
  vertexFieldOrdinal  @0: CoreVertexFieldOrdinal;
  vertexFieldInfo     @1: CoreVec2DTagFieldInfo;
  vertexInfoList      @2: CoreVertexInfoList;
  fieldTypeInfoList   @3: CoreFieldTypeInfoList;
  fieldNames          @4: CoreFieldTagNames;
  memoryConstraint    @5: CoreMemConstraintList;
}

struct CoreComputeSetInfo {
  name @0: Text;
  # debugId @1: UInt32;
  doesExternalExchange @1: Bool;
}
struct CoreComputeSetInfoList {
  size @0: UInt32;
  list @1: List(CoreComputeSetInfo);
}

# FieldSizeMap : VertexIdAndFieldNameTag -> size
struct CoreFieldSizeMap {
  size @0: UInt32;
  list @1: List(VIdTagSizePair);
  struct VIdTagSizePair {
    first @0: CoreVIdAndFieldNameTag;
    second @1: UInt64;
  }
}

# FieldInitValueMap :
#     VertexIdAndFieldNameTag -> vector<char>
struct CoreFieldInitValueMap {
  size @0: UInt32;
  list @1: List(VIdTagVecPair);

  struct VIdTagVecPair {
    tag @0: CoreVIdAndFieldNameTag;
    initValues @1: SmallList;
  }
  struct SmallList {
    size @0: UInt8;
    list @1: List(UInt8);
  }
}
struct CoreIncidence {
  enum Type {
    unset     @0;
    never     @1;
    sometimes @2;
    always    @3;
  }
  type @0: Type;
}

# DataStreamType
struct CoreDataStreamType {
  enum Type {
    hostToDeviceFifo   @0;
    deviceToHostFifo   @1;
    hostToDeviceBuffer @2;
    deviceToHostBuffer @3;
  }
  type @0: Type;
}
# ReplicatedStreamMode
struct CoreReplicatedStreamMode {
  enum Type {
    replicate @0;
    broadcast @1;
  }
  type @0: Type;
}

# DataStream
struct CoreDataStream {
  handle               @0: Text;
  type                 @1: CoreDataStreamType;
  replicationMode      @2: CoreReplicatedStreamMode;
  numElements          @3: UInt32; # Should this be 64 bits?
  simpleType           @4: SimpleType;
  splitInfo            @5: SplitInfo;
  buffering            @6: BufferingOptions;
  prefetch             @7: Bool;
  rearrangementOnHost  @8: CoreIncidence;
  allocation           @9: AllocationOptions;
  hostNumBytes         @10: UInt32; # Should this be 64 bits?
  remoteBufferId       @11: UInt32; # remote_buffer_id
  metadataOffset       @12: UInt32;
  elementSize          @13: UInt8;
  metadataSize         @14: UInt8;

  struct SplitInfo {
    nSplits @0: UInt32;
  }
  struct BufferingOptions {
    depth @0: UInt32;
  }
  struct AllocationOptions {
    enum AddressSpace {
      pageTable @0;
      addressTranslationTable @1;
      serviceTable @2;
    }
    value @0: AddressSpace;
  }
}
struct CoreDataStreamList {
  size @0: UInt32;
  list @1: List(CoreDataStream);
}

struct RemoteBufferRelocationsValue {
  id @0: RemoteBufferId;
  value @1: GraphRelocationList;
}

struct RemoteBufferRelocationsList {
  list @0: List(RemoteBufferRelocationsValue);
}

# RemoteBuffer
struct CoreRemoteBuffer {
  handle @0: Text;
  ipuToRemote @1: UInt32; # data_stream_id
  remoteToIpu @2: UInt32; # data_stream_id
  repeats     @3: UInt32; # size_t
  rearrangeOnHost @4: Bool;
  optimiseMemory  @5: Bool;
}

struct CoreRemoteBufferList {
  size @0: UInt32;
  list @1: List(CoreRemoteBuffer);
}

struct CoreRemoteBufferInitialValue {
  id @0: RemoteBufferId;
  value @1: SmallListChar;
}

struct CoreRemoteBufferInitialValuesList {
  list @0: List(CoreRemoteBufferInitialValue);
}

struct CoreDeltaOffsets {
  deltaNEdgesMap         @0: EdgeKeyUsageMap;
  deltaNElementsEdgesMap @1: EdgeKeyUsageMap;

  struct OffsetList {
    size @0: UInt32;
    list @1: List(RegionList);
  }
  struct EdgeInfo {
    base @0: VSizeT;
    varId @1: CoreVarId;
    field @2: CoreVIdAndFieldNameTag;
  }
  struct Usage {
    size     @0: UInt32;
    edgeInfo @1: List(EdgeInfo);
    storage  @2: OptRegion;
  }
  struct EdgeKey {
    first @0: UInt32;
    second @1: UInt32;
    offsetList @2: OffsetList;
  }
  struct EdgeKeyUsageMap {
    struct EdgeKeyUsagePair  {
      edgeKey   @0: EdgeKey;
      usage @1: Usage;
    }
    size @0: UInt32;
    map  @1: List(EdgeKeyUsagePair);
  }
}
struct CoreDeltaOffsetsList {
  size @0: UInt32;
  list @1: List(CoreDeltaOffsets);
}

struct CoreExchangeBlock {
  ipu              @0: UInt32;
  instance         @1: UInt32;
  incomingMuxReset @2: UInt32;
  context          @3: XBContext;
  edge             @4: XBEdge;

  enum XBContext {
    c0  @0;
    c1  @1;
    c2  @2;
    c3  @3;
  }
  enum XBEdge {
    west @0;
    east @1;
  }
}
struct CoreXBToTileMap {
  struct Pair {
    block @0: CoreExchangeBlock;
    tile @1: UInt32;
  }
  size @0: UInt32;
  map @1: List(Pair);
}

struct CoreBufferPerIpuId {
  ipu @0: UInt32;
  bufferIndex @1: UInt32;
}
struct CorePageTable {
  pageSize @0: CoreSizeT;
  map @1: PageMap;

  struct Page {
    page @0: UInt64;
  }
  struct OptPage {
    hasValue @0: Bool;
    value    @1: Page;
  }
  struct PageInterval {
    lower @0: Page;
    upper @1: Page;
  }
  struct PageMap {
    struct IntervalValPair {
      interval @0: PageInterval;
      value    @1: Int64;
    }
    size @0: UInt32;
    map  @1: List(IntervalValPair);
  }
  struct PageSet {
    size @0: UInt32;
    set  @1: List(PageInterval);
  }
}

struct BufferPerIpuPageTables {
  size     @0: UInt32;
  table    @1: List(BufferPerIpuIdTablePair);
  struct BufferPerIpuIdTablePair {
    bufferPerIpuId @0: CoreBufferPerIpuId;
    pageTable      @1: CorePageTable;
  }
}

struct BufferPerIpuPageSets {
  size    @0: UInt32;
  set     @1: List(BufferPerIpuIdPageSetPair);
  struct BufferPerIpuIdPageSetPair {
    bufferPerIpuId @0: CoreBufferPerIpuId;
    pageSet        @1: CorePageTable.PageSet;
  }
}
struct BufferAllocations {
  hexopt  @0: List(HexoptAllocation);
  hexoatt  @1: List(HexoattAllocation);
  serviceTable @2: List(ServiceTableAllocation);
  struct HexoptAllocation {
    cleartext @0: UInt64;
    capacity  @1: UInt64;
  }
  struct HexoattAllocation {
    cleartext @0: UInt64;
  }
  struct ServiceTableAllocation {
    cleartext @0: UInt64;
  }
}

struct HostExchangeId {
  syncId @0: OptUInt32;
  stream @1: StreamAndIndex;
}
struct CoreHostBufferAddress {
  index  @0: UInt32;
  offset @1: VSizeT;
  size   @2: CoreSizeT;
}

struct CoreSingleRegion {
  begin @0: UInt64;
  end   @1: UInt64;
}
struct ServiceTableMemoryRegions {
  size @0: UInt32;
  list @1: List(CoreSingleRegion);
}
struct RemoteBufferRegion {
  enum Kind {
   singleRegion @0;
   serviceTable @1;
  }
  kind @0: Kind;
  singleRegion @1: CoreSingleRegion;
  serviceTable @2: ServiceTableMemoryRegions;
}
struct RemoteBufferAddress {
  ipu   @0: UInt32;
  regions @1: RemoteBufferRegion;
  repeats @2: UInt32;
  repeatSize @3: UInt64;
}
struct OptReplicationIndex {
  hasValue @0: Bool;
  value    @1: UInt32;
}

struct CoreHostBufferId {
  #  memory is enum :
  #    HostAddress::AddressSpace::PageTable OR
  #    AddressTranslationTable
  memory      @0: UInt32;
  syncGroup   @1: UInt32;
  replica     @2: OptReplicationIndex;
}

# remote_buffer_id
struct RemoteBufferId {
  value @0: UInt32;
}
# ReplicatedRemoteBuffer
struct ReplicatedRemoteBuffer {
  id    @0: RemoteBufferId;
  index @1: UInt32;
}

struct CoreDeviceConfiguration {
  configureMultiReadST @0 :Bool;
  useMultiReadST @1 :Bool;
  identityHexoptTable @2 :Bool;
}

struct CoreHostBufferInfo {
  streamOffsets    @0: StreamAddressMap;
  streamBuffers    @1: StreamBuffersMap;
  hexopts          @2: BufferPerIpuPageTables;
  hexoatts         @3: BufferPerIpuPageTables;
  serviceTableBufferOffsets @4: ServiceTableBufferOffsets;

  struct BufferInfo {
     size @0: CoreSizeT;
  }
  struct StreamAddressMap {
    size @0: UInt32;
    list  @1: List(IdAddressPair);
    struct IdAddressPair {
      id      @0: HostExchangeId;
      address @1: CoreHostBufferAddress;
    }
  }
  struct StreamBuffersMap {
    size @0: UInt32;
    list  @1: List(HBIdBufferInfoPair);
    struct HBIdBufferInfoPair {
      id    @0: CoreHostBufferId;
      info  @1: BufferInfo;
    }
  }

  struct ServiceTableBufferOffsets {
    map   @0: List(TableIdOffsetPair);
    struct TableIdOffsetPair {
      bufferPerIpuId @0: CoreBufferPerIpuId;
      offset      @1: UInt64;
    }
  }
}

# Merge this with Prog StreamRearrangement later
struct CoreStreamRearrangement {
  mappings @0: MappingList;
  patterns @1: PatternList;

  struct MappingList {
     size @0: UInt32;
     list @1: List(Mapping);
  }
  struct PatternList {
     size @0: UInt32;
     list @1: List(Pattern);
  }
  struct Mapping {
    pciSubOffset @0: CoreSizeT;
    streamOffset @1: CoreSizeT;
    size         @2: VSizeT;
  }
  struct Pattern {
    numBuffers @0: UInt64;
    step       @1: UInt64;
    chunkBytes @2: UInt64;
    length     @3: UInt64;
  }
}

struct CoreHostAccess {
  hexoptEntry @0: CorePageTable.OptPage;
  offset @1: UInt64;
}

struct CoreStreamSyncInfo {
  flags @0: Flags;
  hasRearrangementInfo @1: Bool;
  rearrangement @2: CoreStreamRearrangement;
  accesses @3: AccessMap;

  struct Flags {
    prefetchCallback @0: Bool;
    prefetchRearrangement @1: Bool;
    hostToDevice @2: Bool;
  }
  struct AccessInterval {
    lower @0: UInt64;
    upper @1: UInt64;
  }
  struct RegionMap {
    size @0: UInt32;
    map  @1: List(AccessIntervalAccessPair);
    struct AccessIntervalAccessPair {
      key @0: AccessInterval;
      value @1: CoreHostAccess;
    }
  }
  struct RegionMapList {
    size @0: UInt32;
    list @1: List(RegionMap);
  }
  struct AccessMap {
    size @0: UInt32;
    map  @1: List(TableIdRegionMapPair);
    struct TableIdRegionMapPair {
      key @0: CoreBufferPerIpuId;
      value @1: RegionMapList;
    }
  }
}
struct CoreStreamSyncBeginInfo {
   info              @0: CoreStreamSyncInfo;
   nextSyncForStream @1: UInt32;
}
struct CoreStreamSyncEndInfo {
   info              @0: CoreStreamSyncInfo;
   nextSyncForStream @1: UInt32;
}
struct CoreStreamSyncBeginMap {
  size @0: UInt32;
  map  @1: List(Pair);
  struct Pair {
    key @0: DataStreamId;
    value @1: CoreStreamSyncBeginInfo;
  }
}
struct CoreStreamSyncEndMap {
  size @0: UInt32;
  map  @1: List(Pair);
  struct Pair {
    key @0: DataStreamId;
    value @1: CoreStreamSyncEndInfo;
  }
}
struct CoreNextSyncEntry {
  syncId @0: UInt32;
  repeats @1: UInt32;
}
struct CoreNextSync {
  size @0: UInt32;
  list @1: List(CoreNextSyncEntry);
}
struct CoreHostSyncPointInfo {
  streamBegin @0: CoreStreamSyncBeginMap;
  streamEnd   @1: CoreStreamSyncEndMap;
  nextSyncId  @2: CoreNextSync;
  hasBroadcast @3: Bool;
  canPrepareInAdvance @4: Bool;
  canDefer @5: Bool;
  hasControlStreamRead @6: Bool;
  canSkipComplete @7 :Bool;
  nextSyncIdFromProgId @8: Bool;
  broadcastGroupIndex @9: UInt32;
}
struct CoreHostSyncPointInfoList {
  size @0: UInt32;
  list @1: List(CoreHostSyncPointInfo);
}
struct CoreElfSymbols {
   size @0: UInt32;
   listOfList @1: List(ElfSymbolList);
   struct ElfSymbolList {
     size @0: UInt32;
     list @1: List(ElfSymbol);
   }
   struct ElfSymbol {
     symbol @0: Text;
     address @1: VarRegion;
   }
}
struct TileStackList {
  size @0: UInt32;
  list @1: List(TileStackPair);
  struct TileStackPair {
    tile @0: UInt32;
    stack @1: UInt32;
  }
}
struct CoreTileSymbolToVarMapEntry {
  name @0: Text;
  varRegion @1: VarRegion;
}
struct GraphSymbols {
  localSyms @0: List(CoreTileSymbolToVarMapEntry);
  globalSyms @1: List(CoreTileSymbolToVarMapEntry);
}
struct CoreCopyLists {
  size @0: UInt32;
  list @1: List(CopyDesc);
   struct CopyDesc {
     src @0: RegionList;
     dst @1: RegionList;
   }
}
struct CoreTargetLocation {
  memorySpace : union {
    tile @0: UInt32;
    ipuHostAddressSpace @1: UInt32;
  }
  offset @2: UInt64;
}
struct CoreOptTargetLocation {
  hasValue @0: Bool;
  value @1: CoreTargetLocation;
}
struct CoreOptTargetLocationList {
  size @0: UInt32;
  list @1: List(CoreOptTargetLocation);
}
struct CoreHostSyncInfo {
  ipuGroupInfo  @0: IpuGroupInfoList;
  syncPointInfo @1: CoreHostSyncPointInfoList;
  conflicts     @2: List(SyncPointConflict);
  programSyncIdInfo    @3: ProgramSyncIdInfoList;

  struct IpuGroupInfo {
    syncIdStream @0: OptDataStreamId;
    startingSyncId @1: OptUInt32;
  }
  struct IpuGroupInfoList {
    size @0: UInt32;
    list @1: List(IpuGroupInfo);
  }
  struct SyncPointConflict {
    syncA @0 :UInt32;
    syncB @1 :UInt32;
    streams @2 :List(UInt32);
  }
  struct ProgramSyncIdInfoPair {
    programId @0: UInt32;
    syncIds @1: List(OptUInt32);
  }
  struct ProgramSyncIdInfoList {
    size @0: UInt32;
    list @1: List(ProgramSyncIdInfoPair);
  }
}
struct CoreFieldStorageMap {
  size @0: UInt32;
  list @1: List(Pair);
  struct Pair {
     first  @0: CoreVIdAndFieldNameTag;
     second @1: VarRegion;
  }
}
struct CoreRemoteStreamInfo {
  stream @0: DataStreamId;
  rearrangement @1: CoreStreamRearrangement;
}
struct CoreRemoteBufferInfo {
  struct RIdAddressPair {
    id    @0: ReplicatedRemoteBuffer;
    address @1: RemoteBufferAddress;
  }

  allocation @0 :List(UInt64);
  offsets @1 : List(RIdAddressPair);
  rearrangement @2 :List(CoreRemoteStreamInfo);
  hostAddressSpaceOffset @3 :List(UInt64);
}
struct CoreHostFunction {
  handle @0 :Text;
  toHost @1 :List(DataStreamId);
  toDevice @2 :List(DataStreamId);
}
struct CoreGraph {
  numTiles               @0: UInt32;
  typeInfo               @1: CoreGraphTypeInfo;
  symbols                @2: List(GraphSymbols);
  vertexIsWorker         @3: TextToBoolMap;
  vertexSupervisorStackUsage @4: TextToUInt32Map;
  tileStacks             @5: TileStackList;
  computeSetInfoList     @6: CoreComputeSetInfoList;
  fieldSizeMap           @7: CoreFieldSizeMap;
  fieldInitValues        @8: CoreFieldInitValueMap;
  # MISSING                  lateInitFields;
  copyLists              @9: CoreCopyLists;
  streams                @10: CoreDataStreamList;
  remoteBuffers          @11: CoreRemoteBufferList;
  # MISSING                   existingReplicaMaps;
  # MISSING                   replicaSpecificRelocationMaps;
  # MISSING                   existingReplicaSpecificRelocationMaps;
  deltaOffsets           @12: CoreDeltaOffsetsList;
  fieldStorage           @13: CoreFieldStorageMap;
  hostBufferInfo         @14: CoreHostBufferInfo;
  bufferAllocations      @15: BufferAllocations;
  hostSyncInfo           @16: CoreHostSyncInfo;
  zeroLengthReadStream   @17: OptDataStreamId;
  remoteBufferInfo       @18: CoreRemoteBufferInfo;
  tileMemoryUsages       @19: GenListVSizeT;
  numIpuHostAddressSpaces @20: UInt32;
  xreqTile               @21: CoreXBToTileMap;
  idleTiles              @22: GenListBool;
  firstIdleTile          @23: CoreCom.OptTileId;
  mutableGraph           @24: MGraph;
  remoteBufferInitialValues @25: CoreRemoteBufferInitialValuesList;
  remoteBufferRelocations @26: RemoteBufferRelocationsList;
  hostFunctions @27 :List(CoreHostFunction);
  deviceConfiguration @28: CoreDeviceConfiguration;
}
