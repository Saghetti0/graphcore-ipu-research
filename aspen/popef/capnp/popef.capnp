@0xccd20560625ac450; # unique file ID, generated by `capnp id`

using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("popef::capnp");

# File structure

enum BlobType {
  poplarExecutable @0;
  metadata @1;
  dataTensor @2;
  dataFeed @3;
  opaque @4;
}

struct BlobHeader {
  version @0 :Text;
  type @1 :BlobType;
  size @2 :UInt64; # Total size of BlobHeader + data
}

struct Option {
  name @0 :Text;
  value @1 :Text;
}

# Metadata

struct Opaque {
  name @0 :Text;
  executable @1 :Text;
}

struct PoplarExecutable {
  name @0 :Text;
  uncompressedSize @1: UInt64; # Should be -1 if the executable is not compressed
}

enum DataType {
  bool @0;
  f8 @1;
  f16 @2;
  f32 @3;
  f64 @4;
  s8 @5;
  u8 @6;
  s16 @7;
  u16 @8;
  s32 @9;
  u32 @10;
  s64 @11;
  u64 @12;
  f8143 @13;
  f8152 @14;
}

enum TensorType {
  unknown @0;
  input @1;
  output @2;
}

using Shape = List(Int64);

struct TensorInfo {
  shape @0 :Shape;
  dataType @1 :DataType;
}

using ProgramIndex = UInt32;

struct Anchor {
  name @0 :Text;
  programs @1 :List(ProgramIndex);
  handle @2 :Text;
  tensorInfo @3 :TensorInfo;
  type @4 :TensorType;
  # If True, each replica has its own unique tensor representation.
  isPerReplica @5 :Bool;
  # If True, tensor blocks will be copied to the remote buffer (memory outside
  # IPU that can be read and written by the IPU).
  useRemoteBuffers @6 : Bool;
  # The remote buffer can store multiple blocks of data to be transferred. Each
  # block has exactly the same size.
  repeats @7 : UInt32;
}

struct ProgramFlow {
  load @0 :List(ProgramIndex);
  main @1 :List(ProgramIndex);
  save @2 :List(ProgramIndex);
}

struct ProgramInfo {
  index @0 :UInt32;
  name @1 :Text;
}

struct Metadata {
  replicationFactor @0 :UInt32;
  numIpus @1 :UInt32;
  seedHandle @2 :Text;
  anchors @3 :List(Anchor);
  executable @4 :Text;
  numProcesses @5 :UInt32;
  ipuVersion @6 :UInt32;
  isPOD @7 :Bool;
  isInference @8 :Bool;
  engineOptions @9 :List(Option);
  deviceOptions @10 :List(Option);
  programFlow @11 :ProgramFlow;
  programsMap @12 :List(ProgramInfo);
  deviceIterations @13 : UInt32;
}

# Data

struct FeedDataInfo {
  name @0 :Text;
  tensorInfo @1 :TensorInfo;
  numTensors @2 :UInt32;
}

struct TensorDataInfo {
  name @0 :Text;
  tensorInfo @1 :TensorInfo;
}
