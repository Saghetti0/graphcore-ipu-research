@0xfa25e0ad815c5152; # Unique ID generated by `capnp id`

using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("poplar::cap");

using Common = import "Common.capnp";
using CoreCom = import "CoreCommon.capnp";
using Common.SimpleType;
using Common.Region;

using CoreCom.CoreVarId;
using CoreCom.DataStreamId;
using CoreCom.VarRegion;
using CoreCom.OptRegion;
using CoreCom.RegionList;

#BitSet
struct BitSet {
  size @0 : UInt32;
  bits @1 : List(UInt8);
}

#CopyList Id
struct CopyId {
  id @0: UInt32;
}
struct CopyListIds {
  size @0: UInt32;
  ids @1: List(UInt32);
}

#OptHostSync
struct OptHostSync {
  struct HostSync {
    hasSyncId @0: Bool;
    syncId @1: UInt32;
  }
  hasHostSync @0: Bool;
  hostSync @1: HostSync;
}

# IPUs
struct IPUs {
  size @0: UInt32;
  vals @1: List(UInt32);
}

#SyncType
struct SyncType {
  enum  Type {
    internal @0;
    gs1      @1;
    gs2      @2;
  }
  type @0: Type;
}

#SyncCodegens
struct SyncCodegen {
  # 0: Code, 1: SyncOnly, 2: SkipSyncs
  value @0: UInt8;
}
struct SyncCodegens {
  size @0: UInt32;
  codegens @1: List(SyncCodegen);
}

# Series of definitions for
#  TileInfo and StreamCopyInstruction types

struct TileInfoMap {
  struct TileInfo {
    tile @0: UInt32;
    tInfo @1: TileStreamCopyInfo;
  }
  size @0: UInt32;
  map @1: List(TileInfo);
}
struct TileStreamCopyInfo {
  isMaster @0: Bool;
  scheduleSize @1: UInt32;
  schedule @2: List(StreamCopyInstr.Instruction);
  zeroByteRead @3: OptRegion;
  dummyWrite @4: OptRegion;
  wordsReceived @5: UInt32;
}
enum HostExchangePacketType {
  xreq               @0;
  zeroByteRead       @1;
  dummyWrite         @2;
  commandPacketWrite @3;
  commandPacketRead  @4;
  streamCopy         @5;
}
struct StreamCopyInstr {
  struct Instruction {
    insn :union {
      send                          @0: Send;
      delay                         @1: Delay;
      setDowncount                  @2: SetDowncount;
      exitSequence                  @3: ExitSequence;
      syncRecv                      @4: SyncRecv;
      syncInternal                  @5: SyncInternal;
      setupPatchXAddrArg            @6: SetupPatchXAddrArg;
      patchXAddr                    @7: PatchXAddr;
      unpatchXAddr                  @8: UnpatchXAddr;
      multiPatchXAddr               @9: MultiPatchXAddr;
      multiSend                     @10: MultiSend;
      multiSetupAndPatchXAddr       @11: MultiSetupAndPatchXAddr;
      recvData                      @12: RecvData;
      cyclicIncrement               @13: CyclicIncrement;
      setupPatchUpperAndXAddrArg    @14: SetupPatchUpperAndXAddrArg;
      patchCommandPacketUpperAddr   @15: PatchCommandPacketUpperAddr;
      unpatchCommandPacketUpperAddr @16: UnpatchCommandPacketUpperAddr;
      validateOffset                @17: ValidateOffset;
    }
  }
  struct Send {
    cycles @0: UInt32;
    varId @1: CoreVarId;
    offset @2: UInt32;
    bytesRequested @3: UInt32;
    lastSendOfPacket @4: Bool;
    type @5: HostExchangePacketType;
  }
  struct Delay {
    cycles @0: UInt32;
  }
  struct SetDowncount {
    value @0: UInt32;
  }
  struct ExitSequence {
    mustSync @0: Bool;
    includeHost @1: Bool;
  }
  struct SyncRecv {
    dummy @0: UInt32;
  }
  struct SyncInternal {
    dummy @0: UInt32;
  }
  struct SetupPatchXAddrArg {
    offsetRegion @0: OptRegion;
    repeats @1: UInt32;
    chunkSize @2: UInt32;
  }
  struct PatchXAddr {
    var @0: CoreVarId;
    offset @1: UInt32;
  }
  struct UnpatchXAddr {
    var @0: CoreVarId;
    offset @1: UInt32;
  }
  struct LoopWithStride {
    var @0: CoreVarId;
    start @1: UInt32;
    stride @2: UInt32;
    length @3: UInt32;
  }
  struct MultiPatchXAddr {
    loop @0: LoopWithStride;
    patch @1: Bool;
  }
  struct MultiSend {
    repeats @0: UInt32;
    # totalDataSent is used only by profiler
    headerVar @1: VarRegion;
    payload @2: OptRegion;
    bytesRequested @3: UInt32;
  }
  struct MultiSetupAndPatchXAddr {
    patchLoop @0: LoopWithStride;
    setupLoop @1: LoopWithStride;
    patch     @2: Bool;
    chunkSize @3: UInt32;
    repeats   @4: UInt32;
  }
  struct RecvData {
    bytesRequested @0: UInt32;
  }
  struct CyclicIncrement {
    var @0: CoreVarId;
    max @1: UInt32;
  }
  struct SetupPatchUpperAndXAddrArg {
    offsetRegion @0: OptRegion;
    repeats @1: UInt32;
    chunkSize @2: UInt32;
    baseAddress @3: UInt64;
    isReadFromHost @4: Bool;
  }
  struct PatchCommandPacketUpperAddr {
    var @0: CoreVarId;
    offset @1: UInt32;
  }
  struct UnpatchCommandPacketUpperAddr {
    var @0: CoreVarId;
    offset @1: UInt32;
  }
  struct ValidateOffset {
    offsetRegion @0: OptRegion;
    repeats @1: UInt32;
  }
}

#All Progs
struct ProgAbstractSwitch {
  struct SwitchCase {
    key @0: UInt32;
    body @1: Program;
  }
  numCases @0: UInt32;
  cases @1:  List(SwitchCase);
  defaultCase @2:  Program;
  unreachableDefault @3: Bool;
}
struct ProgCall {
  functionId @0: UInt32;
  skipOnTile @1: BitSet;
}
struct ProgCopy {
  copyListId @0: UInt32;
}
struct ProgCrossReplicaCopy {
  struct ReplicaCopy {
    copyId @0: UInt32;
    mapId @1: UInt32;
  }
  size @0: UInt32;
  copies @1: List(ReplicaCopy);
}
struct ProgDoExchange {
  copyListId @0: UInt32;
  # more need to be added
}
struct ProgExecute {
  copyIdExists @0: Bool;
  copyId @1: UInt32;
  computeSetId @2: UInt32;
}

struct ProgOnEveryTileSwitch {
  abstractSwitch @0: ProgAbstractSwitch;
  control @1: VarRegion;
  perTileControl @2: List(VarRegion);
  ipus @3: IPUs;
}

struct ProgOnTileCopy {
  copyListId @0: UInt32;
}

struct ProgOnTileExecute {
  computeSetId @0:UInt32;
  hasCopyId @1: Bool;
  copyId @2:  CopyId;
}

struct ProgOnTileSwitch {
  struct TileRegionPair {
    tile @0: UInt32;
    region @1: VarRegion;
  }
  struct TileRegionMap {
    size @0: UInt32;
    map @1: List(TileRegionPair);
  }
  abstractSwitch @0: ProgAbstractSwitch;
  condTensors @1: TileRegionMap;
}


struct ProgRepeat {
  count @0: UInt32;
  prog @1: Program;
}

struct ProgRepeatWhile {
  cond @0: Program;
  loopCondition @1: Bool;
  body @2: Program;
  ipus @3: IPUs;
}

# Sync, Sans & SyncAns
struct ProgSync {
  type @0: SyncType;
  ipus @1: IPUs;
}
struct ProgSans {
  sizeSans @0: UInt32;
  sansCount @1: List(UInt32);
}
struct ProgSyncAns {
  sync @0: BitSet;
}

# Consensus - local, localFromVar, global
struct ProgSetLocalConsensus {
  value @0: Bool;
}
struct ProgSetLocalConsensusFromVar {
  src @0: VarRegion;
  ipus @1: IPUs;
}
struct ProgGetGlobalConsensus {
  dst @0: VarRegion;
}

struct StreamRearrangement {
  struct Mapping {
    pciSubOffset @0: UInt32;
    streamOffset @1: UInt32;
    size @2: UInt32;
  }
  struct Pattern {
    numBuffers @0: UInt64;
    step @1: UInt64;
    chunkBytes @2: UInt64;
    length @3: UInt64;
  }
  mappingsSize @0: UInt32;
  mappings @1: List(Mapping);
  patternsSize @2: UInt32;
  patterns @3: List(Pattern);
}

struct StreamCopyCopy {
  fromHost  @0: Bool;
  stream    @1: DataStreamId;
  regions   @2: RegionList;
  rearrangeOnHost @3: Bool;
  streamRearrangement @4: StreamRearrangement;
  offsetRegions @5: RegionList;
  repeats @6: UInt32;
  outlineWrites @7: Bool;
  originalCopyId @8: UInt32;
  sharedAllocation @9: Bool;
}
struct StreamCopyCopies {
  size @0: UInt32;
  copies @1: List(StreamCopyCopy);
}

struct ProgStreamCopy {
  hostSyncBefore @0: OptHostSync;
  hostSyncAfter @1: OptHostSync;

  isPreSync @2: Bool;
  preCopies @3: CopyListIds;
  postCopies @4: CopyListIds;

  dataStreamCopies @5: StreamCopyCopies;
  remoteBufferCopies @6:  StreamCopyCopies;

  tileInfo @7: TileInfoMap;
  syncBeforeZeroByteRead @8: Bool;
  # profiling id
  syncGenForTile @9: SyncCodegens;
}

struct ProgStreamCopyBegin {
  syncGenForTile @0: SyncCodegens;
  hostSyncBefore @1: OptHostSync;
  totalBytes @2: UInt32;
  isSyncId   @3: Bool;
  tileInfo   @4: TileInfoMap;
  sectionName @5: Text;
  hostExchangeProgramSym @6: Text;
  #Profiling Id missing
}
struct ProgStreamCopyMid {
  syncGenForTile @0: SyncCodegens;
  dataStreamCopies @1: StreamCopyCopies;
  remoteBufferCopies @2: StreamCopyCopies;
  totalBytes @3: UInt32;
  isSyncId   @4: Bool;
  tileInfo   @5: TileInfoMap;
  sectionName @6: Text;
  hostExchangeProgramSym @7: Text;
}
struct ProgStreamCopyEnd {
  syncGenForTile @0: SyncCodegens;
  hostSyncAfter @1: OptHostSync;
  dataStreamCopies @2: StreamCopyCopies;
  remoteBufferCopies @3: StreamCopyCopies;
  totalBytes @4: UInt32;
  isSyncId   @5: Bool;
  tileInfo   @6: TileInfoMap;
  syncBeforeZeroByteRead @7: Bool;
  sectionName @8: Text;
  hostExchangeProgramSym @9: Text;

}
struct ProgUnloweredExecuteDst {
  functionId @0: UInt32;
  exitDst    @1: VarRegion;
  syncType   @2: SyncType;
  ipus       @3: IPUs;
}

struct ProgUnloweredSwitch {
  abstractSwitch @0: ProgAbstractSwitch;
  control @1: VarRegion;
  ipus    @2: IPUs;
  syncType @3: SyncType;
  isRootSwitch   @4: Bool;
}

struct ProgUnloweredWhile {
  cond @0: Program;
  loopCondition @1: Bool;
  body @2: Program;
  condTensor @3: VarRegion;
  # Complications:  (From UnloweredWhile.hpp
  #  "The sync type gets set in lowerSyncTypes
  #  and will be either INTERNAL or GS1"
  syncType @4: SyncType;
  ipus @5: IPUs;
}
struct ProgAssumeEqualAcrossReplicas {
  regions @0: RegionList;
}

struct ProgWriteUndef {
  regions @0: RegionList;
}

struct Program {
  prog :union {
    call @0                   :ProgCall;
    copy @1                   :ProgCopy;
    crossReplicaCopy @2       :ProgCrossReplicaCopy;
    execute @3                :ProgExecute;

    onEveryTileSwitch @4      :ProgOnEveryTileSwitch;
    onTileCopy @5             :ProgOnTileCopy;
    onTileExecute @6          :ProgOnTileExecute;
    onTileSwitch  @7          :ProgOnTileSwitch;

    repeat       @8           :ProgRepeat;
    repeatWhile  @9           :ProgRepeatWhile;
    sequence @10              :List(Program);
    setLocalConsensus @11     :ProgSetLocalConsensus;
    setLocalConsensusFromVar @12 :ProgSetLocalConsensusFromVar;
    getGlobalConsensus @13    :ProgGetGlobalConsensus;
    streamCopy @14            :ProgStreamCopy;
    streamCopyBegin @15       :ProgStreamCopyBegin;
    streamCopyMid   @16       :ProgStreamCopyMid;
    streamCopyEnd   @17       :ProgStreamCopyEnd;
    sync @18                  :ProgSync;
    sans @19                  :ProgSans;
    syncAns @20               :ProgSyncAns;

    unloweredExecuteDst @21   :ProgUnloweredExecuteDst;
    unloweredSwitch @22       :ProgUnloweredSwitch;
    unloweredWhile @23        :ProgUnloweredWhile;
    writeUndef     @24        :ProgWriteUndef;
    assumeEqualAcrossReplicas @25: ProgAssumeEqualAcrossReplicas;
  }
}
struct ProgramList {
  count @0: UInt32;
  programs @1: List(Program);
}
struct Programs {
  ctrlProgs @0 :ProgramList;
  functions @1 :ProgramList;
}
